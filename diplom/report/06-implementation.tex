\chapter{Технологический раздел}

\section{Средства реализации программного обеспечения}

В качестве языка программирования был выбран Python. Данный выбор обусловлен тем, что Python имеет множество библиотек, таких как TensorFlow, Keras, PyTorch и Theano, которые предоставляют множество инструментов для создания и обучения нейронных сетей.

В качестве библиотеки для создания нейронной сети была выбрана библиотека PyTorch версии 2.0.0, так как она имеет следующие возможности и инструменты:
\begin{itemize}
	\item динамический граф вычислений, использование которого облегчает отладку моделей;
	\item возможность переноса вычислений на GPU;
	\item набор инструментов для создания различных слоев, из которых складывается архитектура нейронной сети;
	\item API на языке C++, что позволяет обучить модель с использованием интерпретируемого языка Python, а использовать ее на компилируемом языке C++.
\end{itemize}

Для работы с большими данными была выбрана библиотека numpy версии 1.21.0, так как она использует оптимизированный код на C, что позволяет выполнять вычисления быстрее, чем с использованием чистого Python, а также потому что классы этой библиотеки интегрируются с библиотекой PyTorch, которая используется для создания нейронной сети.

Для работы с изображениями была выбрана библиотека Pillow версии 8.2.0, так как она позволяет загружать и трансформировать изображения разных форматов, таких как PNG, JPEG, BMP, а также переводить изображения в объекты, которые передаются на вход нейронной сети.

Для создания графического интерфейса использовалась библиотека PyQt версии 5.0, так как она является кроссплатформенной, имеет базовые виджеты, на которых может быть построен интерфейс, а также предоставляет возможность подписки на события, которые генерируются виджетами.
%TODO add refs

\section{Реализация программного комплекса}

В качестве модели классификации используется сверточная нейронная сеть с 12 слоями свертки и 5 слоями пуллинга, которая соединяется с двухслойным перцептроном. После каждого сверточного слоя за исключением последнего используется слой нормализации и функция активации ReLU. Реализация модели приведена в листинге \ref{lst:simple_net.py} (приложение А).

Перед обучением модели выполняется предобработка всего обучающего набора данных, во время которой нужно разбить все входные изображения по классам, привести все изображения к размеру 96 на 96 пикселей, так как только такое изображение обрабатывается моделью, а также поделить весь набор данных на обучающую и тестовую выборки.

После выполнения предобработки нужно произвести аугментацию для расширения обучающей выборки. К каждому изображению в обучающем множестве применяются следующие преобразования: поворот на 30 и 330 градусов, увеличение яркости в полтора раза, а также гауссово размытие, которое создает фильтр Гаусса с заданным размером и силой размытия, и применяют его к изображению, используя операцию свертки. Коэффициенты в фильтре Гаусса вычисляются по формуле \ref{formula:gaussfilter}
\begin{equation}\label{formula:gaussfilter}
G(x,y) = \frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}},
\end{equation}
где $x$ и $y$ -- расстояния от центра ядра по горизонтали и вертикали соответственно, $\sigma$ -- сила размытия.

Исходное изображения и изображения после аугментации приведены на рисунках \ref{img:tensor}-\ref{img:augTensor4}.

Обучение модели проводилось на машине с процессором Intel Core i9-10900, 64 гигабайтами оперативной памяти и графической картой NVIDIA GeForce RTX 3080 с 16 гигабайтами памяти типа GDDR6. Время прохождения одной эпохи для модели классификации в среднем занимает 5 минут 4 секунды, а для модели детектирования -- 6 минут 15 секунд.

В качестве оптимизатора функции потерь был выбран Adam, так как он автоматически адаптирует скорость обучения для каждого параметра в зависимости от его градиента, что позволяет более эффективно использовать скорость обучения и ускоряет сходимость.

Обучение модели останавливается, когда точность распознавания на тестовой выборке после прохождения очередной эпохи становится меньше, чем на двух предыдущих, так как это свидетельствует о том, что сеть начала переобучаться.

Код обработки и загрузки обучающего набора данных представлен в листинге \ref{lst:dataset_handler.py}. Реализация алгоритмов обучения и прохождения одной эпохи представлены на листингах \ref{lst:INetworkController.py} и \ref{lst:NetworkController.py} соответственно. Все листинги находятся в приложении А.

Графики зависимостей точности модели классификации на тестовой и обучающей выборках от номера эпохи обучения приведены на рисунке \ref{img:model_training}.

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}
		\begin{axis}[
		xlabel = {номер эпохи},
		ylabel = {точность},
		legend pos=south east,
		ymajorgrids=true,
		width=12cm
		]   
		\addplot[color=blue, mark=square] table[x index=0, y index=1] {inc/data/model_training.dat};
		
		\addplot[color=red, mark=*] table[x index=0, y index=1] {inc/data/model_test.dat};
		
		
		\addlegendentry{Тренировочная}
		\addlegendentry{Тестовая}
		
		\end{axis}
		\end{tikzpicture}
		\caption{Обучение модели}
		\label{img:model_training}
	\end{center}
\end{figure}

Из графиков видно, что после 9 эпохи модель начинает переобучаться и требуется остановить обучение. Итоговая точность полученной модели на тестовой выборке составила 84 процента.

В качестве модели детектирования была реализована сверточная нейронная сеть, состоящая из 106 слоев. В качестве функции активации была выбрана функция ReLU. Разработанная модель имеет три выходных слоя, каждый из которых имеет размерность (3xSxSx5), где 3 -- число якорей, S -- размер ячейки, для 3 выходов размеры ячеей будут 25, 50 и 100 соответственно, вектор из пяти элементов состоит из вероятности нахождения центра объекта внутри ячейки, а также координат его центра, высоты и ширины рамки.

Графики зависимости точности детектирования объектов и вероятности ложного срабатывания представлены на рисунке \ref{img:yolo_training}. Объект считался корректно распознанным, если отношение площади пересечения полученной рамки с эталоном к площади их объединения составляло больше 0.6. Детектированный объект считался ложным, если отношение площади пересечения его рамки ни с одной из эталонных к площади их объединения не составляло больше 0.1.

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}
		\begin{axis}[
		xlabel = {номер эпохи},
		ylabel = {точность},
		legend pos=south east,
		ymajorgrids=true,
		width=12cm
		]   
		\addplot[color=blue, mark=square] table[x index=0, y index=1] {inc/data/yolo_error.dat};
		
		\addplot[color=red, mark=*] table[x index=0, y index=1] {inc/data/yolo_test.dat};
		
		
		\addlegendentry{Ложное срабатывание}
		\addlegendentry{Тестовая}
		
		\end{axis}
		\end{tikzpicture}
		\caption{Обучение модели}
		\label{img:yolo_training}
	\end{center}
\end{figure}


\section{Взаимодействие с разработанным ПО}

Взаимодействие с разработанным программным обеспечение осуществляется через графический пользовательский интерфейс. Интерфейс приложения представлен на рисунке \ref{img:gui}.


Графический интерфейс поделен на две части. Первая часть позволяет выбрать и загрузить модель обученную на классификацию и проверить ее работу. Вторая позволяет выбрать и загрузить модель, обученную на детектирование, а также проверить ее работу вместе с моделью классификации.

\section{Тестирование}

\section{Вывод}

В рамках данного раздела были выбраны и реализованы средства распознавания летательных аппаратов. Для этого были выбраны методы аугментации обучающих данных, направленные на увеличение количества и разнообразия данных для обучения модели. 

Были созданы модели для детектирования и классификации летательных аппаратов и реализован алгоритм их обучения. После этого были проведены тесты для оценки качества моделей. Итоговая точность модели классификации на тестовой выборке составила 84 процента. Точность детектирования на тестовой выборке составила 90 процентов.

Кроме того, был создан графический интерфейс, который позволяет пользователям использовать обученную модель для распознавания типов летательных аппаратов. После этого было проведено ручное тестирование обученных моделей, чтобы убедиться в правильности их работы.