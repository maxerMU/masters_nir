\chapter{Разработка метода}

\section{Разделяемый кэш буфер PostgreSQL}

Кэширование используется в современных компьютерных системах повсеместно: один только процессор имеет три или четыре уровня кэша.
В общем случае кэш нужен для того, чтобы сгладить разницу в производительности двух видов памяти, один из которых в разы быстрее, но меньше по размеру, а другой имеет обратные характеристики размера и времени доступа.
Буферный кэш сохраняет страницы в оперативной памяти, доступ к которой в сотни тысяч раз быстрее, чем к дисковому хранилищу, где содержится вся информация о состоянии базы данных.

В операционной системе также есть дисковый кэш, который решает ту же проблему, поэтому системы управления базами данных обычно стараются избежать двойного кэширования, обращаясь к дискам напрямую, а не через кэш ОС. 
В случае с PostgreSQL это не так: все данные читаются и записываются с помощью обычных файловых операций \cite{shaik2020postgresql}.
При разработке метода важно учитывать, что контроллеры дисковых массивов и даже сами диски также имеют свой собственный кэш.

Буферный кэш является списком буферов, каждый из которых состоит из блока данных и заголовка.
Заголовок содержит:
\begin{itemize}
	\item номер блока страницы;
	\item индикатор того, что страница была изменена, но еще не записана на диск;
	\item число обращений к буферу;
	\item число активных операций или транзакций, которые используют буфер. 
\end{itemize}

При старте все буферы кэша помещаются в список свободных.
Для поиска нужной страницы используется хэш таблица.
В качестве ключа используются номер файла и номер страницы в файле.

При обращении к памяти процесс сначала пытается найти страницу в кэше.
Если она уже загружена, то счетчик обращений в заголовке соответствующего буфера увеличивается на единицу.
До тех пор, пока это счетчик не равен нулю, страница не может быть выгружена из кэша.

Если страница не была найдена в кэше, то она должна быть прочитана с диска в какой-то буфер.
Если список свободных буферов не пуст, то будет взят первый буфер из него, иначе требуется выбрать буфер, который будет вытеснен из кэша.

В PostgreSQL для выбора кандидата на замещение анализируются два счетчика -- число обращений и количество использований.
Алгоритм часы поочередно проходит по всем буферам в кэше и, если оба счетчика равны нулю, то текущий буфер будет замещен, иначе оба счетчика уменьшаются на единицу.
Для избежания большого числа проходов по всем буферам в поисках кандидата на замещение по умолчанию счетчики не могут быть больше пяти.

Когда кандидат на замещение найден, счетчик использований ассоциированного с ним буфера устанавливается в 1, чтобы другие процессы не могли его использовать.
Если буфер содержит не записанную диск информацию, то запускается фоновый процесс переписывания страницы на диск.
После этого новая страница загружается в буфер и для нее выставляется счетчик обращений в единицу.

\section{Постановка задачи}
Пусть, размер разделяемого кэш буфера в СУБД равен $B$.
Тогда в каждый момент времени $t$, когда возникает новое обращение к странице в памяти, СУБД пытается найти нужный буфер в кэше.
Если он отсутствует и кэш заполнен, то при помощи алгоритма замещения должна быть выбрана страница, которая будет вытеснена из буфера.
Результатом работы метода является $a^t \in \{0, 1, ..., B-1\}$ -- индекс страницы, которая будет вытеснена.

Для оценки разработанного алгоритма будут использованы следующие метрики качества:
\begin{itemize}
	\item коэффициента попадания -- отношение числа обращений к страницам, которые уже загружены в буфере, к общему числу обращений;
	\item коэффициент совпадения -- показывает отношение количества совпавших с оптимальным алгоритмов кандидатов на замещение с общим числом запросов поиска буфера для вытеснения.
\end{itemize}

\section{Описание модели}
Разрабатываемая модель состоит из четырех компонентов \cite{deepBM}:
\begin{enumerate}
	\item Кодировщик запроса доступа к странице -- полносвязная нейронная сеть, которая на вход получает атрибуты запрашиваемой страницы, а на выходе выдает вектор $e_t$ размерности $d_e$.
	\item Кодировщик страниц в буфере -- полносвязная нейронная сеть, на вход которой поступают атрибуты страниц в буфере и результатом которой является список векторов для каждой страницы в буфере. Размерность каждого вектора равна $d_b$.
	\item Кодировщик истории обращений к страницам;
	\item Модуль выбора страницы для замещения. 
\end{enumerate}

\textbf{Кодировщик запроса доступа к странице.}
При каждом запросе страницы из запроса извлекаются следующие параметры:
\begin{itemize}
	\item $rel\_id$ -- идентификатор отношения;
	\item $is\_local\_temp$ -- флаг, который отвечает показывает является отношение временным в текущей сессии;
	\item $fork\_num$ -- тип физического хранилища;
	\item $blk\_num$ -- номер блока в файле;
	\item $mode$ -- метод чтения страницы;
	\item $rel\_am$ -- тип индекса;
	\item $rel\_file\_node$ -- идентификатор физического хранилища;
	\item $has\_index$ -- флаг наличия индекса;
	\item $rel\_persistence$ -- тип хранения объекта (постоянный, временный, объект, который не ведет журнал транзакций);
	\item $rel\_kind$ -- тип отношения: обычная таблица, индекс, последовательность, таблица с специальной техникой хранения больших объектов, отображение, сложный тип, внешняя таблица, разделенная таблица, разделенный индекс;
	\item $rel\_natts$ -- список пользовательских атрибутов;
	\item $relfrozenxid$ -- идентификатор транзакции, который указывает на момент, когда все старые версии строк в данной таблице были заморожены;
	\item $relminmxid$ -- минимальный идентификатор многоверсионной транзакции для данной таблицы.
\end{itemize}

Помимо описанных выше атрибутов к входным параметрам модели добавляется индекс страницы в буфере, если она там есть, или число равное размеру буфера, как признак отсутствия страницы в нем.

Для представления категориальных данных применяется техника однозначного кодирования \cite{onecode}, при которой каждая категория представляет бинарным вектором, размер которого совпадает с числом категорий.
Такой подход позволяет представить категории в виде дискретных типов без введения отношения порядка над ними.

Входные данные поступают на вход полносвязной нейронной сети с одним скрытым слоем \cite{митина2021перцептрон}.
Результатом работы сети является вектор признаков размерностью $d_e$.

\textbf{Кодировщик страниц в буфере.}
Кодировщик страниц в буфере работает аналогично кодировщику запроса доступа.
Единственным отличием является другой набор обучаемых весов и входных параметров.
На вход нейронной сети помимо атрибутов каждой страницы также поступает закодированное представление индекса в буфере.
Для кодирования индекса сначала применяется техника однозначного кодирования, а затем преобразование его в вектор размерности $d_f$ путем умножения на обучающиеся матрицы смежности.

\textbf{Кодировщик истории обращения к страницам.}
Для запоминания истории запросов к буферу использована рекуррентная нейронная сеть LSTM \cite{yu2019review}.
На вход сети поступает вектор из кодировщика запросов доступа страницы.
Результатом работы сети является вектор $h^t$ размера $d_h$, который описывает историю обращений.

Сеть LSTM состоит из четырех компонентов.
Ключевой из них -- состояние ячейки, которая переходит между повторяющимися модулями сети, подвергаясь преобразованиям.
Три других компонента отвечают за забывание прошлого состояния ячейки, обновление состояния на основе входных данных и выхода из прошлого модуля, а также за получение выходного значения из текущего блока.

Первый компонент нужен для определения того, какую часть информации можно выбросить из состояния ячейки.
На вход к нему поступают входные данные в текущий блок и выходной вектор из прошлого модуля.
На выходе при помощи сигмоидного фильтра для каждого значения в состоянии ячейки вычисляется число от 0 до 1, после чего происходит поточечное умножение чисел в ячейке на полученных из фильтра забывания значения.

Задача следующего компонента -- определить какая новая информация будет сохранена в ячейке.
Для этого сначала при помощи сигмоидного входного фильтра определяются значения, которые будут сохранены в ячейке, а затем с использованием слоя гиперболического тангенса вычисляются новые значения кандидатов на попадание в ячейку.
После этих операций выполняется поточечное суммирование элементов в ячейке с полученными кандидатами.

Задача последнего компонента -- определить, какая информация будет на выходе из текущего модуля.
Для этого используется поточечное умножение текущего состояния ячейки, пропущенного через фильтр гиперболического тангенса, и входных данных, объединенных с выходом из прошлого модуля и прошедших через сигмоидный фильтр.

\textbf{Модуль выбора страницы для замещения.}
Для принятия решения о том, какая страница будет вытеснена из буфера используется еще одна полносвязная нейронная сеть.
На вход сети поступают выходной вектор из кодировщика истории обращения к страницам и список выходных векторов из кодировщика страниц в буфере.
Результатом работы сети является вектором размером, совпадающим с количеством элементов в кэше, где каждый элемент показывает вероятность того, что та или иная страница должна быть замещена.
Для замещения будет выбрана страница с наибольшей вероятностью.

\section{Получение обучающей выборки}
Для создания обучающей выборки необходимо получить последовательность обращений к страницам в буфере.
Имея такую последовательность, каждый раз, когда требуется исключить страницу из буфера, можно выбрать кандидата при помощи оптимального алгоритма.

Такая последовательность была получена путем модификации исходного кода PostgreSQL и добавления логгирования в функцию ReadBufferExtended, которая вызывается каждый раз, когда необходимо прочитать страницу из буфера.

Для получения информации о свойствах запрашиваемого отношения используется поле rd\_rel структуры Relation, которая передается в функцию в качестве входного аргумента.
Тип физического хранилища, номер блока в файле и метод чтения страницы также являются входными аргументами функции.
Для проверки того, является ли отношение временным, анализируется поле backend у структуры RelFileLocatorBackend.
Для проверки того, загружена ли страница в буфер, анализируется возвращаемое значение из текущей реализации функции замещения страниц.

\section{Детализированная IDEF-0}

Детализированная IDEF-0 диаграмма представлена на рисунке \ref{img:idef0}.

\includeimage
{idef0} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{\textwidth} % Ширина рисунка
{Детализированная IDEF-0 диаграмма} % Подпись рисунка

Запрос обращения к странице проходит через кодировщик запросов и попадает в блок, который отвечает за историю обращений.
Текущая история обращений к страницам и закодированные страницы, которые в данных момент находятся в буфере, попадают на вход блока, который отвечает за выбор страницы для замещений.

\section{Структура ПО}

Структура ПО приведена на рисунке \ref{img:structure}.
Каждый блок, представленный в детализированной idef0 диаграмме, является отдельным модулем в структуре программного обеспечения.
Также отдельный модуль отвечает за получения обучающей выборки при моделировании типовой нагрузки на СУБД.

\includeimage
{structure} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{\textwidth} % Ширина рисунка
{Структура ПО} % Подпись рисунка