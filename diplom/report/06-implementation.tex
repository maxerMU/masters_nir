\chapter{Технологический раздел}

\section{Средства реализации программного обеспечения}

В качестве языка программирования был выбран Python~\cite{Python}. Данный выбор обусловлен тем, что Python имеет множество библиотек, таких как TensorFlow, Keras, PyTorch, которые предоставляют множество инструментов для создания и обучения нейронных сетей.

В качестве библиотеки для создания нейронной сети была выбрана библиотека PyTorch~\cite{PyTorch} версии 2.0.0, так как она имеет следующие возможности и инструменты:
\begin{itemize}
	\item динамический граф вычислений, использование которого облегчает отладку моделей;
	\item возможность переноса вычислений на GPU;
	\item набор инструментов для создания различных слоев, из которых складывается архитектура нейронной сети;
	\item API на языке C++, что позволяет обучить модель с использованием интерпретируемого языка Python, а использовать ее на компилируемом языке C++.
\end{itemize}

Для работы с большими данными была выбрана библиотека numpy версии 1.21.0, так как она использует оптимизированный код на C, что позволяет выполнять вычисления быстрее, чем с использованием чистого Python, а также потому что классы этой библиотеки интегрируются с библиотекой PyTorch, которая используется для создания нейронной сети.

Для анализа входных данных использовались библиотеки matplotlib, pandas и seaborn.
Pandas поддерживает чтение данных из различных форматов данных в структуру DataFrame -- таблицу с индексами и метками, а также совместимость с другими библиотеками, такими как numpy, для передачи данных.
Matplotlib имеет возможность создания различных видов графиков: линейные, столбчатые, гистограммы, а также имеет интеграцию с Jupyter Notebook для интерактивной визуализации.
Seaborn позволяет строить карту корреляций для элементов Dataframe.

Для создания графического интерфейса был использован фреймворк PyQT~\cite{qt}, так как он является кроссплатформенным, имеет собственную библиотеку стандартных виджетов, имеет документацию по всем структурам, а также поддерживает последние стандарты языка Python и имеет дополнительные утилиты такие как QtDesigner, которые упрощают создание графических интерфейсов.

\section{Разработка программного комплекса}

Для создания обучающей выборки необходимо провести следующую временную модификацию в СУБД PostgreSQL: нужно найти функцию, которая вызывается каждый раз при обращении к страницам в буфере и добавить в эту функцию вызов функции для записи информации о странице в специальный файл.

Для управления разделяемым кэш буфером используются следующие функции:
\begin{enumerate}
	\item ReadBuffer -- захватывает буфер, увеличивает его pin count, и загружает страницу в буфер, если её там нет.
	\item ReleaseBuffer -- уменьшает pin count буфера, освобождая его для возможного повторного использования.
	\item LockBuffer, LockBufferForCleanUp, ConditionalLockBufferForCleanUp -- управление блокировками.
	\item BgBufferSync -- фоновая запись измененных буферов на диск.
	\item CheckPoint -- управление контрольными точками.
	\item MarkBufferDirty -- помечает буфер, как требующий записи на диск.
	\item FlushBuffer -- сбрасывает содержимое буфера на диск.
	\item BufferAlloc -- выделяет буфер для новой страницы.
\end{enumerate}

Функция ReadBuffer принимает указатель на структуру отношения, для которого читается блок данных, и номер блока для чтения.
Внутри функции ReadBuffer происходит вызов функции ReadBufferExtended, которая дополнительно принимает имя физического хранилища, способ чтения и стратегию управления буфером.
Вся логика обращений и изменений разделяемого кэш буфера написана внутри функции ReadBufferExtended.
Эта функция вызывается с различными аргументами еще из 66 мест, поэтому именно в нее надо добавлять запись в лог файл с информацией об обращении к странице.
Модифицированный код функции ReadBufferExtended приведен в листинге~\ref{lst:read_buffer_ext.c} (приложение А).

Для реализации кодировщика запросов обращения к странице был разработан класс PageAccEncoder.
Класс является наследником класса Module из библиотеки PyTorch:
\begin{itemize}
	\item слои эмбеддиногов, которые преобразуют атрибуты страницы в некоторые скрытые вектора;
	\item полносвязная сеть, которая объединяет результаты эмбедингов для каждого атрибута страницы и создает скрытое представление страницы.
\end{itemize}

Для целочисленных атрибутов применяется модель HashEmbedding, которая сначала вычисляет хэш функцию, а затем к полученному значению применяет слой эмбеддинга.
Для категориальных атрибутов он применяется сразу.

Полносвязный слой является последовательным применением Linear блока и функции активации ReLU.
Реализация класса PageAccEncoder представлена в листинге~\ref{lst:page_acc_enc.py} (приложение А).

Для реализации кодировщика страниц в буфере был разработан класс PageBufferEncoder.
Этот класс является наследником PageAccEncoder, так как с каждой страницей в буфере требуется выполнить те же действия, что и с страницей, к которой идет новое обращение.
Для параллелизации и ускорения процессов взаимодействия с моделью перед применением слое модели для всех атрибутов страниц в буфере вызывается функция torch.stack, которая нужная для конкатенации тензоров вдоль новой оси.
Реализация класса PageBufferEncoder представлена в листинге~\ref{lst:buf_page_enc.py}.

В качестве кодировщика истории обращений используется библиотечная модель LSTM.

Для реализации модуля выбора страниц для замещения был разработан класс PageEviction, который наследуется от класса Module из библиотеки PyTorch.
Модель состоит из трех линейных слоев:
\begin{itemize}
	\item attention\_page -- преобразует скрытое представление страницы в буфере в пространство внимания;
	\item attention\_context -- преобразует результат работы кодировщика истории в это же пространство;
	\item attention\_v -- вычисляет итоговые оценки внимания на основе объединенных признаков из пространства внимания.
\end{itemize}
Реализация класса PageEviction представлена в листинге~\ref{lst:page_eviction.py}.

Класс PageAccModel объединяет в себе все 4 описанных выше модуля.
Процесс обработки входных данных и выбора страницы для замещения состоит из четырех шагов:
\begin{itemize}
	\item кодирование запроса обращения к странице -- используется модель PageAccEncoder;
	\item обновление истории обращений -- используется модель LSTM;
	\item кодирование страниц в буфере -- используется модель PageBufferEncoder;
	\item выбор страницы для замещения -- используется модуль PageEviction.
\end{itemize}
Реализация класса PageAccModel представлена в листинге~\ref{lst:page_acc_model.py}.

\section{Обучение и тестирование модели}

Обучение модели проводилось на машине с процессором Intel Core i9-10900, 64 гигабайтами оперативной памяти и графической картой NVIDIA GeForce RTX 3080 с 16 гигабайтами памяти типа GDDR6.

В качестве оптимизатора функции потерь был выбран Adam, так как он автоматически адаптирует скорость обучения для каждого параметра в зависимости от его градиента, что позволяет более эффективно использовать скорость обучения и ускоряет сходимость.

Обучение модели проводилось на протяжении 100 эпох.
После прохождения каждой эпохи веса модели сохранялись в файл и вычислялась точность модели на тестовой выборке.
Была выбрана модель с наивысшей точностью на тестовой выборке.

Графики зависимостей точности модели на тестовой и обучающей выборках от номера эпохи обучения приведены на рисунке~\ref{img:training_512}.

\includeimage
{training_512} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{0.8\textwidth} % Ширина рисунка
{Точность при обучении модели на тренировочной и тестовой выборках} % Подпись рисунка

Наивысшая точность модели была получена на 97 эпохе -- 44.2 процента.
Точность на обучающей выборке составила 63 процента.

\section{Взаимодействие с разработанным ПО}

Взаимодействие с разработанным программным обеспечение осуществляется через графический пользовательский интерфейс. Интерфейс приложения представлен на рисунке~\ref{img:gui}.

\includeimage
{gui} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{0.8\textwidth} % Ширина рисунка
{Интерфейс разработанного приложения} % Подпись рисунка


Графический интерфейс поделен на две части.
Первая часть позволяет выбрать и загрузить выборку для тестирования, обученную модель и оптимальные результаты, а также выбрать номер обращения, на котором требуется сравнить алгоритмы замещения.
Вторая часть является таблицей, которая отображает результаты работы методов.
В первом столбце таблице написано название метода, затем индекс выбранной методом страницы для замещения, затем число, которое показывает через сколько обращений к буферу выбранную страницу необходимо будет загрузить обратно.

\section{Вывод}

В рамках данного раздела были выбраны средства реализации программного обеспечения метода замещения страниц с использованием нейронных сетей.
В качестве языка программирования был выбран Python, а для проектирования и обучения нейронных сетей была использована библиотека PyTorch. 

Также был проведен анализ функций в СУБД PostgreSQL и проведена модификация одной из функций для созданий обучающей выборки.

Были созданы и обучены модели, которые решают свои подзадачи в рамках метода замещения страниц: кодирование запросов обращения к страницам, кодирование страниц в буфере, кодирование истории обращений, а также модель для выбора страницы для замещения на основе скрытого представления страниц в буфере и контекста, полученного из кодировщика истории.

Точность совпадений с оптимальным алгоритмом на обучающей выборке составила 63 процента, а на тестовой -- 44.2 процента.